#include <MFRC522.h>                        // Library responsible for communicating with the module RFID-RC522
#include <SPI.h>                            // Library responsible for communicating of SPI bus

#define SS_PIN          21
#define RST_PIN         22
#define SIZE_BUFFER     18
#define MAX_SIZE_BLOCK  16

MFRC522::MIFARE_Key key;                    // Used in authentication
MFRC522::StatusCode status;                 // Authentication return status code
MFRC522 mfrc522(SS_PIN, RST_PIN);           // Defined pins to module RC522

void setup() {
  Serial.begin(9600);
  SPI.begin();                              // Init SPI bus
  
  mfrc522.PCD_Init();                       // Init MFRC522 
  Serial.println("Approach your reader card...");
  Serial.println();
}

void loop() {
  if (!mfrc522.PICC_IsNewCardPresent()) {   // Waiting the card approach
    return;
  }

  if ( ! mfrc522.PICC_ReadCardSerial()) {   // Select a card
    return;
  }

  mfrc522.PICC_DumpToSerial(&(mfrc522.uid));  // Dump debug info about the card; PICC_HaltA() is automatically called
  int op = menu();                          // Call menu function and retrieve the desired option

  if(op == 0) 
    readingData();
  else if(op == 1) 
    writingData();
  else {
    Serial.println(F("Incorrect Option!"));
    return;
  }
 
  mfrc522.PICC_HaltA();                     // Instructs the PICC when in the ACTIVE state to go to a "STOP" state 
  mfrc522.PCD_StopCrypto1();                // Stop the encryption of the PCD, it must be called after comm with auth, otherwise new comm can not be initiated
}

void readingData() {
  mfrc522.PICC_DumpDetailsToSerial(&(mfrc522.uid)); // Prints the technical details of the card/tag
  
  for (byte i = 0; i < 6; i++) {            // Prepare the key (keys are set to FFFFFFFFFFFFh)
    key.keyByte[i] = 0xFF;
  }
  
  byte buffer[SIZE_BUFFER] = {0};           // Buffer for read data
 
  byte block = 1;                           // The block to operate
  byte size = SIZE_BUFFER;                  // Authenticates the block to operate
  status = mfrc522.PCD_Authenticate(MFRC522::PICC_CMD_MF_AUTH_KEY_A, block, &key, &(mfrc522.uid)); // Line 880 of MFRC522.cpp
  
  if (status != MFRC522::STATUS_OK) {
    Serial.print(F("Authentication failed: "));
    Serial.println(mfrc522.GetStatusCodeName(status));
    return;
  }

  status = mfrc522.MIFARE_Read(block, buffer, &size); // Read data from block
  if (status != MFRC522::STATUS_OK) {
    Serial.print(F("Reading failed: "));
    Serial.println(mfrc522.GetStatusCodeName(status));
    return;
  }

  Serial.print(F("\nData from block ["));
  Serial.print(block);Serial.print(F("]: "));

  for (uint8_t i = 0; i < MAX_SIZE_BLOCK; i++) {  // Prints read data
      Serial.write(buffer[i]);
  }
  Serial.println(" ");
}

void writingData() {
  mfrc522.PICC_DumpDetailsToSerial(&(mfrc522.uid)); // Prints technical details from of the card/tag
  
  Serial.setTimeout(30000L);                // Waits 30 seconds dor data entry via Serial      
  Serial.println(F("Enter the data to be written with the '#' character at the end \n[maximum of 16 characters]:"));

  for (byte i = 0; i < 6; i++) {            // Prepare the key (keys are set to FFFFFFFFFFFFh)
    key.keyByte[i] = 0xFF;
  }
  
  byte buffer[MAX_SIZE_BLOCK] = "";         // Buffer for storing data to write
  byte block;                               // The block to operate
  byte dataSize;                            // Size of data

  dataSize = Serial.readBytesUntil('#', (char*)buffer, MAX_SIZE_BLOCK); // Recover on buffer the data from Serial before #

  for(byte i=dataSize; i < MAX_SIZE_BLOCK; i++) { // Fill with whitespace after #
    buffer[i] = ' ';
  }
 
  block = 1;                                // The block to operate
  String str = (char*)buffer;               // Transforms the buffer data in String
  Serial.println(str);

  status = mfrc522.PCD_Authenticate(MFRC522::PICC_CMD_MF_AUTH_KEY_A, block, &key, &(mfrc522.uid));  // Authenticates the block to operate

  if (status != MFRC522::STATUS_OK) {
    Serial.print(F("PCD_Authenticate() failed: "));
    Serial.println(mfrc522.GetStatusCodeName(status));
    return;
  }
  Serial.println(F("PCD_Authenticate() success: "));
 
  status = mfrc522.MIFARE_Write(block, buffer, MAX_SIZE_BLOCK); // Writes in the block
  if (status != MFRC522::STATUS_OK) {
    Serial.print(F("MIFARE_Write() failed: "));
    Serial.println(mfrc522.GetStatusCodeName(status));
    return;
  }
  else {
    Serial.println(F("MIFARE_Write() success: "));
  }
}

int menu()
{
  Serial.println(F("\nChoose an option:"));
  Serial.println(F("0 - Reading data"));
  Serial.println(F("1 - Writing data\n"));

  while (!Serial.available()){};              // Waits while the user does not start data
  
  int op = (int)Serial.read();                // Retrieves the chosen option
  
  while (Serial.available()) {                // Remove all characters after option
    if (Serial.read() == '\n') break; 
    Serial.read();
  }
  
  return (op-48);                             // Subtract 48 from read value, 48 is the ascii zero
}
