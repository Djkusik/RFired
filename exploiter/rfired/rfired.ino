#include <MFRC522.h>                        // Library responsible for communicating with the module RFID-RC522
#include <SPI.h>                            // Library responsible for communicating of SPI bus
#include "SPIFFS.h"

#define SS_PIN          21
#define RST_PIN         22
#define SIZE_BUFFER     18
#define MAX_SIZE_BLOCK  16

MFRC522::MIFARE_Key key;                    // Used in authentication
MFRC522::MIFARE_Key correctKey;
MFRC522::StatusCode status;                 // Authentication return status code
MFRC522 mfrc522(SS_PIN, RST_PIN);           // Defined pins to module RC522

File defaultKeys;

MFRC522::MIFARE_Key testKey = {keyByte: {0x1A, 0x98, 0x2C, 0x7E, 0x45, 0x9A}};
MFRC522::MIFARE_Key defaultKey = {keyByte: {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}};

void setup() {
  Serial.begin(9600);
  SPI.begin();                              // Init SPI bus
  mfrc522.PCD_Init();                       // Init MFRC522
  
  // Mount SPIFFS
  if (!SPIFFS.begin(true)) {
    Serial.println(F("An error has occurred while mounting SPIFFS"));
    return;
  }
  
  key = defaultKey;                         // Prepare the default factory A/B key
  
  Serial.println(F("Let's start the fun"));
  Serial.print(F("Using default key: "));
  dump_byte_array(key.keyByte,MFRC522::MF_KEY_SIZE);
  Serial.println();
}

void loop() {
  if ( ! mfrc522.PICC_IsNewCardPresent()) {   // Waiting the card approach
    return;
  }

  if ( ! mfrc522.PICC_ReadCardSerial()) {   // Select a card
    return;
  }

//  for (byte i = 0; i < 6; i++) {            // Prepare the key (keys are set to FFFFFFFFFFFFh)
//    key.keyByte[i] = 0xFF;
//  }
//  // Show some details of the PICC (that is: the tag/card)
//  Serial.print(F("Card UID:"));
//  dump_byte_array(mfrc522.uid.uidByte, mfrc522.uid.size);
//  Serial.println();
//  Serial.print(F("PICC type: "));
//  MFRC522::PICC_Type piccType = mfrc522.PICC_GetType(mfrc522.uid.sak);
//  Serial.println(mfrc522.PICC_GetTypeName(piccType));
//
//  // Check for compatibility
//  if (piccType != MFRC522::PICC_TYPE_MIFARE_MINI
//      && piccType != MFRC522::PICC_TYPE_MIFARE_1K
//      && piccType != MFRC522::PICC_TYPE_MIFARE_4K) {
//    Serial.println(F("This sample only works with MIFARE Classic cards."));
//    return;
//  }
//
//  // change keys in section 15 block 63
//  if (!MIFARE_SetKeys(&newKeyA, &newKeyB, &key, &key, 15)) {
//    return;
//  }
//  mfrc522.PICC_DumpToSerial(&(mfrc522.uid));  // Dump debug info about the card; PICC_HaltA() is automatically called
  int op = menu();                          // Call menu function and retrieve the desired option

  switch(op) {
    case 0:
      readingData();
      break;
    case 1:
      writingData();
      break;
    case 2:
      changeKey();
      break;
    case 3:
      readKeysList();
      break;
    case 4:
      bruteKey();
      break;
    default:
      Serial.println(F("Incorrect option!"));
      return;
  }
 
  mfrc522.PICC_HaltA();                     // Instructs the PICC when in the ACTIVE state to go to a "STOP" state 
  mfrc522.PCD_StopCrypto1();                // Stop the encryption of the PCD, it must be called after comm with auth, otherwise new comm can not be initiated
}

void readingData() {
  mfrc522.PICC_DumpDetailsToSerial(&(mfrc522.uid)); // Prints the technical details of the card/tag
  MFRC522::PICC_Type piccType = mfrc522.PICC_GetType(mfrc522.uid.sak);

  switch (piccType) {
    case MFRC522::PICC_TYPE_MIFARE_MINI:
    case MFRC522::PICC_TYPE_MIFARE_1K:
    case MFRC522::PICC_TYPE_MIFARE_4K:
      mfrc522.PICC_DumpMifareClassicToSerial(&(mfrc522.uid), piccType, &key);
      break;
    case MFRC522::PICC_TYPE_MIFARE_UL:
      mfrc522.PICC_DumpMifareUltralightToSerial();
      break;
    case MFRC522::PICC_TYPE_UNKNOWN:
    case MFRC522::PICC_TYPE_NOT_COMPLETE:
    default:
      status = MFRC522::STATUS_OK;
      Serial.println(F("PICC type not recognized/implemented"));
      break;
  }

  if (status != MFRC522::STATUS_OK) {
    Serial.print(F("Authentication failed: "));
    Serial.println(mfrc522.GetStatusCodeName(status));
    return;
  }

  mfrc522.PICC_HaltA();

//  byte block = 0;                           // The block to operate
//  status = mfrc522.PCD_Authenticate(MFRC522::PICC_CMD_MF_AUTH_KEY_A, block, &key, &(mfrc522.uid)); // Line 880 of MFRC522.cpp

//  status = mfrc522.MIFARE_Read(block, buffer, &size); // Read data from block
}

void writingData() {
  byte buffer[MAX_SIZE_BLOCK] = "";         // Buffer for storing data to write
  byte block;                               // The block to operate
  byte dataSize;                            // Size of data
  
  mfrc522.PICC_DumpDetailsToSerial(&(mfrc522.uid)); // Prints technical details from of the card/tag
  
  Serial.setTimeout(30000L);                // Waits 30 seconds dor data entry via Serial      
  Serial.println(F("Enter the data to be written with the '#' character at the end\n[maximum of 16 characters]: "));
  dataSize = Serial.readBytesUntil('#', (char*)buffer, MAX_SIZE_BLOCK); // Recover on buffer the data from Serial before #

  // Fill with whitespace after #
  for (byte i = dataSize; i < MAX_SIZE_BLOCK; i++) {
    buffer[i] = ' ';
  }

  String str = (char*)buffer;               // Transforms the buffer data in String
  Serial.println(str);

  Serial.setTimeout(30000L);                // Waits 30 seconds dor data entry via Serial      
  Serial.println(F("Enter block number\n[0-63]: "));

  while (!Serial.available()){}
  block = (byte)Serial.read();
  
  while (Serial.available()) {                // Remove all characters after option
    if (Serial.read() == '\n') break; 
    Serial.read();
  }

  if (block < 0 || block > 63) {
    block = 1;
  }

  status = mfrc522.PCD_Authenticate(MFRC522::PICC_CMD_MF_AUTH_KEY_A, block, &key, &(mfrc522.uid));  // Authenticates the block to operate

  if (status != MFRC522::STATUS_OK) {
    Serial.print(F("PCD_Authenticate() failed: "));
    Serial.println(mfrc522.GetStatusCodeName(status));
    return;
  }
  Serial.println(F("PCD_Authenticate() success: "));
 
  status = mfrc522.MIFARE_Write(block, buffer, MAX_SIZE_BLOCK); // Writes in the block
  if (status != MFRC522::STATUS_OK) {
    Serial.print(F("MIFARE_Write() failed: "));
    Serial.println(mfrc522.GetStatusCodeName(status));
    return;
  }
  else {
    Serial.println(F("MIFARE_Write() success: "));
  }
}

void changeKey() {
  mfrc522.PICC_DumpDetailsToSerial(&(mfrc522.uid)); // Prints the technical details of the card/tag
  MFRC522::PICC_Type piccType = mfrc522.PICC_GetType(mfrc522.uid.sak);

  // Check for compatibility
  if (piccType != MFRC522::PICC_TYPE_MIFARE_MINI
      && piccType != MFRC522::PICC_TYPE_MIFARE_1K
      && piccType != MFRC522::PICC_TYPE_MIFARE_4K) {
    Serial.println(F("This sample only works with MIFARE Classic cards."));
    return;
  }

  Serial.print(F("Choose sector\n[0-15, 16==all]: \n"));
  while (!Serial.available()){};              // Waits while the user does not start data
  
  int sector = Serial.parseInt();                // Retrieves the chosen option
  
  while (Serial.available()) {                // Remove all characters after option
    if (Serial.read() == '\n') break; 
    Serial.read();
  }

  if (sector < 0 || sector > 17) {
    sector = 1;
  }
  
  if (sector == 16) {
    for (int i = 0; i < 16; i++) {
      if (!MIFARE_SetKeys(&key, &key, &testKey, &testKey, i)) {
        Serial.print(F("Problem when changing sector: "));
        Serial.println(i);
        return;
      }
    }
  }
  else if (sector == 17) {
    Serial.println(F("I'm coming for rescue!"));
    for (int i = 0; i < 16; i++) {
      if (!MIFARE_SetKeys(&testKey, &testKey, &defaultKey, &defaultKey, i)) {
        Serial.print(F("Problem when changing sector: "));
        Serial.println(i);
      }
    }
  }
  else {
    if (!MIFARE_SetKeys(&key, &key, &testKey, &testKey, sector)) {
      return;
    }
//    if (!MIFARE_SetKeys(&testKey, &testKey, &key, &k2ey, sector)) {
//      return;
//    }
  }
  return;
}

bool MIFARE_SetKeys(MFRC522::MIFARE_Key* oldKeyA, MFRC522::MIFARE_Key* oldKeyB,
                    MFRC522::MIFARE_Key* newKeyA, MFRC522::MIFARE_Key* newKeyB,
                    int sector) {
  byte trailerBlock = sector * 4 + 3;
  byte buffer[18];
  byte size = sizeof(buffer);

  // Authenticate using key A
  Serial.print(F("Authenticating using key A: "));
  dump_byte_array(oldKeyA->keyByte, MFRC522::MF_KEY_SIZE);
  Serial.println();
  status = (MFRC522::StatusCode)mfrc522.PCD_Authenticate(MFRC522::PICC_CMD_MF_AUTH_KEY_A, trailerBlock, oldKeyA, &(mfrc522.uid));
  
  if (status != MFRC522::STATUS_OK) {
    Serial.print(F("PCD_Authenticate() failed: "));
    Serial.println(mfrc522.GetStatusCodeName(status));
    return false;
  }

  // Show the whole sector as it currently is
  Serial.print(F("Current data in sector "));
  Serial.println(sector);
  mfrc522.PICC_DumpMifareClassicSectorToSerial(&(mfrc522.uid), oldKeyA, sector);
  Serial.println();

  // Read data from the block
  Serial.print(F("Reading data from block ")); Serial.print(trailerBlock);
  Serial.println(F(" ..."));
  status = (MFRC522::StatusCode) mfrc522.MIFARE_Read(trailerBlock, buffer, &size);
  
  if (status != MFRC522::STATUS_OK) {
    Serial.print(F("MIFARE_Read() failed: "));
    Serial.println(mfrc522.GetStatusCodeName(status));
    return false;
  }
  
  Serial.print(F("Data in block ")); Serial.print(trailerBlock); Serial.println(F(":"));
  dump_byte_array(buffer, 16); Serial.println();
  Serial.println();

  // Authenticate using key B
  Serial.println(F("Authenticating again using key B: "));
  dump_byte_array(oldKeyB->keyByte, MFRC522::MF_KEY_SIZE);
  Serial.println();
  status = (MFRC522::StatusCode)mfrc522.PCD_Authenticate(MFRC522::PICC_CMD_MF_AUTH_KEY_B, trailerBlock, oldKeyB, &(mfrc522.uid));
  
  if (status != MFRC522::STATUS_OK) {
    Serial.print(F("PCD_Authenticate() failed: "));
    Serial.println(mfrc522.GetStatusCodeName(status));
    return false;
  }

  if (newKeyA != nullptr || newKeyB != nullptr) {
    for (byte i = 0; i < MFRC522::MF_KEY_SIZE; i++) {
      if (newKeyA != nullptr) {
        buffer[i] = newKeyA->keyByte[i];
      }
      if (newKeyB != nullptr) {
        buffer[i+10] = newKeyB->keyByte[i];
      }
    }
  }

  // Write data to the block
  Serial.print(F("Writing data into block ")); Serial.print(trailerBlock);
  Serial.println(F(" ..."));
  status = (MFRC522::StatusCode) mfrc522.MIFARE_Write(trailerBlock, buffer, 16);
  
  if (status != MFRC522::STATUS_OK) {
    Serial.print(F("MIFARE_Write() failed: "));
    Serial.println(mfrc522.GetStatusCodeName(status));
    return false;
  }
  Serial.println();

  // Read data from the block (again, should now be what we have written)
  Serial.print(F("Reading data from block ")); Serial.print(trailerBlock);
  Serial.println(F(" ..."));
  status = (MFRC522::StatusCode)mfrc522.MIFARE_Read(trailerBlock, buffer, &size);
  
  if (status != MFRC522::STATUS_OK) {
    Serial.print(F("MIFARE_Read() failed: "));
    Serial.println(mfrc522.GetStatusCodeName(status));
  }
  
  Serial.print(F("Data in block ")); Serial.print(trailerBlock); Serial.println(F(":"));
  dump_byte_array(buffer, 16); Serial.println();
  return true;
}

void readKeysList() {
  defaultKeys = SPIFFS.open("/extended-std.keys");
  if (!defaultKeys) {
    Serial.println(F("Failed to open file for reading"));
  }

  Serial.println(F("File content:"));
  while (defaultKeys.available()) {
    Serial.write(defaultKeys.read());
  }

  defaultKeys.close();
}

void getNextKeyFromFile() {
  byte b1, b2;
  for (byte i = 0; i < MFRC522::MF_KEY_SIZE; i++) {
    b1 = getNextByteFromFile();
    b2 = getNextByteFromFile();
    key.keyByte[i] = createHexFromBytes(b1, b2);
  }
  getNextByteFromFile();
}

char getNextByteFromFile() {
  if (defaultKeys.available())
    return defaultKeys.read();
}

void dump_byte_array(byte* buffer, byte bufferSize) {
  for (byte i = 0; i < bufferSize; i++) {
    Serial.print(buffer[i] < 0x10 ? " 0" : " ");
    Serial.print(buffer[i], HEX);
  }
}

unsigned char createHexFromBytes (byte b1, byte b2) {
  unsigned char finalHex;
  unsigned char c1, c2;

  c1 = createHexHelper(b1);
  c2 = createHexHelper(b2);
  finalHex = c1<<4 | c2;

  return finalHex;
}

byte createHexHelper(byte b) {
  if (b < 58 && b > 47) {
    return b - 48;
  }
  if (b < 71 && b > 64) {
    return b- 55;
  }
  Serial.println(F("Wrong value during createHexHelper"));
  return b;
}

void bruteKey() {
  defaultKeys = SPIFFS.open("/extended-std.keys");
  if (!defaultKeys) {
    Serial.println(F("Failed to open file for reading"));
  }

  Serial.println(F("Started bruting"));
  while(defaultKeys.available()) {
    for (int i = 0; i < 16; i++) {
      getNextKeyFromFile();
        if (validateKey(i)) {
          foundKey();
          correctKey = key;
          readingData();
          return;
        }
    }
  }
}

void foundKey() {
  Serial.print(F("Found correct key: "));
  dump_byte_array(key.keyByte,MFRC522::MF_KEY_SIZE);
  Serial.println();
}

bool validateKey(int sector) {
  // Authenticate using key A
  Serial.print(F("Authenticating using key: "));
  dump_byte_array(key.keyByte,MFRC522::MF_KEY_SIZE);
  Serial.println();
  byte trailerBlock = sector * 4 + 3;
  
  status = (MFRC522::StatusCode)mfrc522.PCD_Authenticate(MFRC522::PICC_CMD_MF_AUTH_KEY_A, trailerBlock, &key, &(mfrc522.uid));
  if (status != MFRC522::STATUS_OK) {
    Serial.print(F("PCD_Authenticate() failed: "));
    Serial.println(mfrc522.GetStatusCodeName(status));
    return false;
  }
  return true;
}

int menu()
{
  Serial.println(F("\nChoose an option:"));
  Serial.println(F("0 - Reading data"));
  Serial.println(F("1 - Writing data"));
  Serial.println(F("2 - Change key"));
  Serial.println(F("3 - Print keys from list"));
  Serial.println(F("4 - Brute keys\n"));

  while (!Serial.available()){};              // Waits while the user does not start data
  
  int op = (int)Serial.read();                // Retrieves the chosen option
  
  while (Serial.available()) {                // Remove all characters after option
    if (Serial.read() == '\n') break; 
    Serial.read();
  }
  
  return (op - 48);                             // Subtract 48 from read value, 48 is the ascii zero
}
