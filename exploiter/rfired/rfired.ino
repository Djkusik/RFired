#include <MFRC522.h>                                    // Library responsible for communicating with the module RFID-RC522
#include <SPI.h>                                        // Library responsible for communicating of SPI bus
#include "SPIFFS.h"

// Const defines
#define SS_PIN            21
#define RST_PIN           22
#define SIZE_BUFFER       18
#define MAX_SIZE_BLOCK    16
#define MAX_SECTOR_AMOUNT 16
#define MAX_FILE_NAME     25

// Global vars, which helps in communication through different modules
MFRC522::MIFARE_Key key;                                // Used in authentication
MFRC522::MIFARE_Key correctKeys[MAX_SECTOR_AMOUNT];     // Saved keys for sectors
MFRC522::StatusCode status;                             // Authentication return status code
MFRC522 mfrc522(SS_PIN, RST_PIN);                       // Defined pins to module RC522

MFRC522::MIFARE_Key defaultKey = {keyByte: {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}};

// Hacky code timeout problems flags
bool timeoutFlag;
size_t counter;

// For test cases hardcoded keys
MFRC522::MIFARE_Key testKey = {keyByte: {0x1A, 0x98, 0x2C, 0x7E, 0x45, 0x9A}};
MFRC522::MIFARE_Key testKey2 = {keyByte: {0x4D, 0x3A, 0x99, 0xC3, 0x51, 0xDD}};

void setup() {
  Serial.begin(9600);
  SPI.begin();                                          // Init SPI bus
  mfrc522.PCD_Init();                                   // Init MFRC522
  
  // Mount SPIFFS
  if (!SPIFFS.begin(true)) {
    Serial.println(F("An error has occurred while mounting SPIFFS"));
    return;
  }
  
  initDefaultKeys();                                    // Init default keys array

  // Hacky code initial values
  timeoutFlag = false;
  counter = 0;

  Serial.println(F("Let's start the fun (or find the bug here)"));
  Serial.print(F("Using default key: "));
  dumpByteArray(key.keyByte, MFRC522::MF_KEY_SIZE);
  Serial.println();
}

void loop() {
  if ( ! mfrc522.PICC_IsNewCardPresent()) {             // Waiting the card approach
    return;
  }

  if ( ! mfrc522.PICC_ReadCardSerial()) {               // Select a card
    return;
  }

  Serial.println();
  mfrc522.PICC_DumpDetailsToSerial(&(mfrc522.uid));

  int op = menu();                                      // Call menu function and retrieve the desired option
  menuOptions(op);
 
  mfrc522.PICC_HaltA();                               // Instructs the PICC when in the ACTIVE state to go to a "STOP" state 
  mfrc522.PCD_StopCrypto1();                          // Stop the encryption of the PCD, it must be called after comm with auth, otherwise new comm can not be initiated
}

// Initalizing array with default key
void initDefaultKeys() {
  key = defaultKey;
  for (byte i = 0; i < MAX_SECTOR_AMOUNT; i++) {
    correctKeys[i] = defaultKey;
  }
}

// Overwritten lib function, because of need having return status
bool PICC_DumpMifareClassicSectorToSerial(MFRC522::Uid *uid,      ///< Pointer to Uid struct returned from a successful PICC_Select().
                          MFRC522::MIFARE_Key *key,  ///< Key A for the sector.
                          byte sector     ///< The sector to dump, 0..39.
                          ) {
  MFRC522::StatusCode status;
  byte firstBlock;    // Address of lowest address to dump actually last block dumped)
  byte no_of_blocks;    // Number of blocks in sector
  bool isSectorTrailer; // Set to true while handling the "last" (ie highest address) in the sector.
  
  // The access bits are stored in a peculiar fashion.
  // There are four groups:
  //    g[3]  Access bits for the sector trailer, block 3 (for sectors 0-31) or block 15 (for sectors 32-39)
  //    g[2]  Access bits for block 2 (for sectors 0-31) or blocks 10-14 (for sectors 32-39)
  //    g[1]  Access bits for block 1 (for sectors 0-31) or blocks 5-9 (for sectors 32-39)
  //    g[0]  Access bits for block 0 (for sectors 0-31) or blocks 0-4 (for sectors 32-39)
  // Each group has access bits [C1 C2 C3]. In this code C1 is MSB and C3 is LSB.
  // The four CX bits are stored together in a nible cx and an inverted nible cx_.
  byte c1, c2, c3;    // Nibbles
  byte c1_, c2_, c3_;   // Inverted nibbles
  bool invertedError;   // True if one of the inverted nibbles did not match
  byte g[4];        // Access bits for each of the four groups.
  byte group;       // 0-3 - active group for access bits
  bool firstInGroup;    // True for the first block dumped in the group
  
  // Determine position and size of sector.
  if (sector < 32) { // Sectors 0..31 has 4 blocks each
    no_of_blocks = 4;
    firstBlock = sector * no_of_blocks;
  }
  else if (sector < 40) { // Sectors 32-39 has 16 blocks each
    no_of_blocks = 16;
    firstBlock = 128 + (sector - 32) * no_of_blocks;
  }
  else { // Illegal input, no MIFARE Classic PICC has more than 40 sectors.
    return false;
  }
    
  // Dump blocks, highest address first.
  byte byteCount;
  byte buffer[18];
  byte blockAddr;
  isSectorTrailer = true;
  invertedError = false;  // Avoid "unused variable" warning.
  for (int8_t blockOffset = no_of_blocks - 1; blockOffset >= 0; blockOffset--) {
    blockAddr = firstBlock + blockOffset;
    // Sector number - only on first line
    if (isSectorTrailer) {
      if(sector < 10)
        Serial.print(F("   ")); // Pad with spaces
      else
        Serial.print(F("  ")); // Pad with spaces
      Serial.print(sector);
      Serial.print(F("   "));
    }
    else {
      Serial.print(F("       "));
    }
    // Block number
    if(blockAddr < 10)
      Serial.print(F("   ")); // Pad with spaces
    else {
      if(blockAddr < 100)
        Serial.print(F("  ")); // Pad with spaces
      else
        Serial.print(F(" ")); // Pad with spaces
    }
    Serial.print(blockAddr);
    Serial.print(F("  "));
    // Establish encrypted communications before reading the first block
    if (isSectorTrailer) {
      status = mfrc522.PCD_Authenticate(MFRC522::PICC_CMD_MF_AUTH_KEY_A, firstBlock, key, uid);
      if (status != MFRC522::STATUS_OK) {
        Serial.print(F("PCD_Authenticate() failed: "));
        Serial.println(mfrc522.GetStatusCodeName(status));
        return false;
      }
    }
    // Read block
    byteCount = sizeof(buffer);
    status = mfrc522.MIFARE_Read(blockAddr, buffer, &byteCount);
    if (status != MFRC522::STATUS_OK) {
      Serial.print(F("MIFARE_Read() failed: "));
      Serial.println(mfrc522.GetStatusCodeName(status));
      continue;
    }
    // Dump data
    for (byte index = 0; index < 16; index++) {
      if(buffer[index] < 0x10)
        Serial.print(F(" 0"));
      else
        Serial.print(F(" "));
      Serial.print(buffer[index], HEX);
      if ((index % 4) == 3) {
        Serial.print(F(" "));
      }
    }
    // Parse sector trailer data
    if (isSectorTrailer) {
      c1  = buffer[7] >> 4;
      c2  = buffer[8] & 0xF;
      c3  = buffer[8] >> 4;
      c1_ = buffer[6] & 0xF;
      c2_ = buffer[6] >> 4;
      c3_ = buffer[7] & 0xF;
      invertedError = (c1 != (~c1_ & 0xF)) || (c2 != (~c2_ & 0xF)) || (c3 != (~c3_ & 0xF));
      g[0] = ((c1 & 1) << 2) | ((c2 & 1) << 1) | ((c3 & 1) << 0);
      g[1] = ((c1 & 2) << 1) | ((c2 & 2) << 0) | ((c3 & 2) >> 1);
      g[2] = ((c1 & 4) << 0) | ((c2 & 4) >> 1) | ((c3 & 4) >> 2);
      g[3] = ((c1 & 8) >> 1) | ((c2 & 8) >> 2) | ((c3 & 8) >> 3);
      isSectorTrailer = false;
    }
    
    // Which access group is this block in?
    if (no_of_blocks == 4) {
      group = blockOffset;
      firstInGroup = true;
    }
    else {
      group = blockOffset / 5;
      firstInGroup = (group == 3) || (group != (blockOffset + 1) / 5);
    }
    
    if (firstInGroup) {
      // Print access bits
      Serial.print(F(" [ "));
      Serial.print((g[group] >> 2) & 1, DEC); Serial.print(F(" "));
      Serial.print((g[group] >> 1) & 1, DEC); Serial.print(F(" "));
      Serial.print((g[group] >> 0) & 1, DEC);
      Serial.print(F(" ] "));
      if (invertedError) {
        Serial.print(F(" Inverted access bits did not match! "));
      }
    }
    
    if (group != 3 && (g[group] == 1 || g[group] == 6)) { // Not a sector trailer, a value block
      int32_t value = (int32_t(buffer[3])<<24) | (int32_t(buffer[2])<<16) | (int32_t(buffer[1])<<8) | int32_t(buffer[0]);
      Serial.print(F(" Value=0x")); Serial.print(value, HEX);
      Serial.print(F(" Adr=0x")); Serial.print(buffer[12], HEX);
    }
    Serial.println();
  }
  
  return true;
}

// Overwritten lib function, because of reading problem when sectors are encrypted with different keys
void PICC_DumpMifareClassicToSerial(  MFRC522::Uid *uid,     ///< Pointer to Uid struct returned from a successful PICC_Select().
                        MFRC522::PICC_Type piccType, ///< One of the PICC_Type enums.
                        MFRC522::MIFARE_Key *key   ///< Key A used for all sectors.
                      ) {
  byte no_of_sectors = 0;
  switch (piccType) {
    case MFRC522::PICC_TYPE_MIFARE_MINI:
      // Has 5 sectors * 4 blocks/sector * 16 bytes/block = 320 bytes.
      no_of_sectors = 5;
      break;
      
    case MFRC522::PICC_TYPE_MIFARE_1K:
      // Has 16 sectors * 4 blocks/sector * 16 bytes/block = 1024 bytes.
      no_of_sectors = 16;
      break;
      
    case MFRC522::PICC_TYPE_MIFARE_4K:
      // Has (32 sectors * 4 blocks/sector + 8 sectors * 16 blocks/sector) * 16 bytes/block = 4096 bytes.
      no_of_sectors = 40;
      break;
      
    default: // Should not happen. Ignore.
      break;
  }
  
  // Dump sectors, highest address first.
  if (no_of_sectors) {
    Serial.println(F("Sector Block   0  1  2  3   4  5  6  7   8  9 10 11  12 13 14 15  AccessBits"));
    for (int8_t i = no_of_sectors - 1; i >= 0; i--) {
      // Added content, for connection reset, case of using key which is not correct for every sector
      isTimeout(key);
      timeoutFlag = !(PICC_DumpMifareClassicSectorToSerial(uid, key, i));
    }
  }
}

// Read data, PICC sensitive
void readFullData(MFRC522::MIFARE_Key* cKey) {
  mfrc522.PICC_DumpDetailsToSerial(&(mfrc522.uid));     // Prints the technical details of the card/tag
  MFRC522::PICC_Type piccType = mfrc522.PICC_GetType(mfrc522.uid.sak);

  switch (piccType) {                                   // Choose PICC type of card
    case MFRC522::PICC_TYPE_MIFARE_MINI:
    case MFRC522::PICC_TYPE_MIFARE_1K:
    case MFRC522::PICC_TYPE_MIFARE_4K:
      PICC_DumpMifareClassicToSerial(&(mfrc522.uid), piccType, cKey);
      break;
      
    case MFRC522::PICC_TYPE_MIFARE_UL:
      mfrc522.PICC_DumpMifareUltralightToSerial();
      break;
      
    case MFRC522::PICC_TYPE_UNKNOWN:
    case MFRC522::PICC_TYPE_NOT_COMPLETE:
    default:
      status = MFRC522::STATUS_OK;
      Serial.println(F("PICC type not recognized/implemented"));
      break;
  }
}

// Reading sector using library function
void readChosenSector(MFRC522::MIFARE_Key* cKey, int sector) {
  isTimeout(cKey);
  timeoutFlag = !(PICC_DumpMifareClassicSectorToSerial(&(mfrc522.uid), cKey, sector));
}

// Wrapper for reading, mainly for printing header
void readChosenWrapper(MFRC522::MIFARE_Key cKey[], int lSector, int rSector) {
  mfrc522.PICC_DumpDetailsToSerial(&(mfrc522.uid));     // Prints the technical details of the card/tag
  Serial.println(F("Sector Block   0  1  2  3   4  5  6  7   8  9 10 11  12 13 14 15  AccessBits"));
  if (lSector < 0) lSector = 0;
  if (rSector > 15) rSector = 15;
  
  for (int i = rSector; i >= lSector; i--) {
    readChosenSector(&cKey[i], i);
  }
}

// Function writing to tag blocks
void writingData() {
  byte buffer[MAX_SIZE_BLOCK] = "";                     // Buffer for storing data to write
  byte block = 1;                                       // The block to operate
  byte dataSize;                                        // Size of data
  
  mfrc522.PICC_DumpDetailsToSerial(&(mfrc522.uid));     // Prints technical details from of the card/tag
  
  Serial.setTimeout(30000L);                            // Waits 30 seconds dor data entry via Serial      
  Serial.println(F("Enter the data to be written with the '#' character at the end\n[maximum of 16 characters]: "));
  dataSize = Serial.readBytesUntil('#', (char*)buffer, MAX_SIZE_BLOCK); // Recover on buffer the data from Serial before #

  // Fill with whitespace after #
  for (byte i = dataSize; i < MAX_SIZE_BLOCK; i++) {
    buffer[i] = ' ';
  }

  String str = (char*)buffer;                           // Transforms the buffer data in String
  Serial.println(str);

  Serial.setTimeout(30000L);                            // Waits 30 seconds dor data entry via Serial      
  Serial.println(F("Enter block number\n[0-63]: "));

  while (!Serial.available()){}
  block = (byte)Serial.read();                          // Which sector to write
  
  while (Serial.available()) {                          // Remove all characters after option
    if (Serial.read() == '\n') break; 
    Serial.read();
  }

  if (block < 0 || block > 63) {
    block = 1;
  }

  writeData(&key, &key, block, buffer);
}


void changeKey() {
  mfrc522.PICC_DumpDetailsToSerial(&(mfrc522.uid));     // Prints the technical details of the card/tag
  MFRC522::PICC_Type piccType = mfrc522.PICC_GetType(mfrc522.uid.sak);

  // Check for compatibility
  if (piccType != MFRC522::PICC_TYPE_MIFARE_MINI
      && piccType != MFRC522::PICC_TYPE_MIFARE_1K
      && piccType != MFRC522::PICC_TYPE_MIFARE_4K) {
    Serial.println(F("This sample only works with MIFARE Classic cards."));
    return;
  }

  Serial.print(F("Choose sector\n[0-15, 16==all]: \n"));
  while (!Serial.available()){};                        // Waits while the user does not start data
  
  int sector = Serial.parseInt();                       // Retrieves the chosen option

  if (sector < 0 || sector > 17) {
    sector = 1;
  }
  
  if (sector == MAX_SECTOR_AMOUNT) {
    for (int i = 0; i < MAX_SECTOR_AMOUNT; i++) {
      isTimeout(&key);
      if (!MIFARE_SetKeys(&key, &key, &testKey, &testKey, i)) {
        timeoutFlag = true;
        Serial.print(F("Problem when changing sector: "));
        Serial.println(i);
        return;
      }
    }
  }
  
  // Special case for development purposes - reset key to default
  else if (sector == 17) {
    Serial.println(F("I'm coming for rescue!"));
    for (int i = 0; i < MAX_SECTOR_AMOUNT; i++) {
      isTimeout(&key);
      if (!MIFARE_SetKeys(&testKey, &testKey, &defaultKey, &defaultKey, i)) {
        timeoutFlag = true;
        Serial.print(F("Problem when changing sector: "));
        Serial.println(i);
      }
    }
  }
  else {
    if (!MIFARE_SetKeys(&key, &key, &testKey, &testKey, sector)) {
      timeoutFlag = true;
      return;
    }
  }
  return;
}

// Function for changing keys from library
bool MIFARE_SetKeys(MFRC522::MIFARE_Key* oldKeyA, MFRC522::MIFARE_Key* oldKeyB,
                    MFRC522::MIFARE_Key* newKeyA, MFRC522::MIFARE_Key* newKeyB,
                    int sector) {
  byte trailerBlock = sector * 4 + 3;
  byte buffer[18];
  byte size = sizeof(buffer);

  // Authenticate using key A
  Serial.print(F("Authenticating using key A: "));
  dumpByteArray(oldKeyA->keyByte, MFRC522::MF_KEY_SIZE);
  Serial.println();
  status = (MFRC522::StatusCode)mfrc522.PCD_Authenticate(MFRC522::PICC_CMD_MF_AUTH_KEY_A, trailerBlock, oldKeyA, &(mfrc522.uid));
  
  if (status != MFRC522::STATUS_OK) {
    Serial.print(F("PCD_Authenticate() failed: "));
    Serial.println(mfrc522.GetStatusCodeName(status));
    return false;
  }

  // Show the whole sector as it currently is
  Serial.print(F("Current data in sector "));
  Serial.println(sector);
  mfrc522.PICC_DumpMifareClassicSectorToSerial(&(mfrc522.uid), oldKeyA, sector);
  Serial.println();

  // Read data from the block
  Serial.print(F("Reading data from block ")); Serial.print(trailerBlock);
  Serial.println(F(" ..."));
  status = (MFRC522::StatusCode) mfrc522.MIFARE_Read(trailerBlock, buffer, &size);
  
  if (status != MFRC522::STATUS_OK) {
    Serial.print(F("MIFARE_Read() failed: "));
    Serial.println(mfrc522.GetStatusCodeName(status));
    return false;
  }
  
  Serial.print(F("Data in block ")); Serial.print(trailerBlock); Serial.println(F(":"));
  dumpByteArray(buffer, MAX_SIZE_BLOCK); Serial.println();
  Serial.println();

  // Authenticate using key B
  Serial.println(F("Authenticating again using key B: "));
  dumpByteArray(oldKeyB->keyByte, MFRC522::MF_KEY_SIZE);
  Serial.println();
  status = (MFRC522::StatusCode)mfrc522.PCD_Authenticate(MFRC522::PICC_CMD_MF_AUTH_KEY_B, trailerBlock, oldKeyB, &(mfrc522.uid));
  
  if (status != MFRC522::STATUS_OK) {
    Serial.print(F("PCD_Authenticate() failed: "));
    Serial.println(mfrc522.GetStatusCodeName(status));
    return false;
  }

  if (newKeyA != nullptr || newKeyB != nullptr) {
    for (byte i = 0; i < MFRC522::MF_KEY_SIZE; i++) {
      if (newKeyA != nullptr) {
        buffer[i] = newKeyA->keyByte[i];
      }
      if (newKeyB != nullptr) {
        buffer[i+10] = newKeyB->keyByte[i];
      }
    }
  }

  // Write data to the block
  Serial.print(F("Writing data into block ")); Serial.print(trailerBlock);
  Serial.println(F(" ..."));
  status = (MFRC522::StatusCode) mfrc522.MIFARE_Write(trailerBlock, buffer, MAX_SIZE_BLOCK);
  
  if (status != MFRC522::STATUS_OK) {
    Serial.print(F("MIFARE_Write() failed: "));
    Serial.println(mfrc522.GetStatusCodeName(status));
    return false;
  }
  Serial.println();

  // Read data from the block (again, should now be what we have written)
  Serial.print(F("Reading data from block ")); Serial.print(trailerBlock);
  Serial.println(F(" ..."));
  status = (MFRC522::StatusCode)mfrc522.MIFARE_Read(trailerBlock, buffer, &size);
  
  if (status != MFRC522::STATUS_OK) {
    Serial.print(F("MIFARE_Read() failed: "));
    Serial.println(mfrc522.GetStatusCodeName(status));
  }
  
  Serial.print(F("Data in block ")); Serial.print(trailerBlock); Serial.println(F(":"));
  dumpByteArray(buffer, MAX_SIZE_BLOCK); Serial.println();
  return true;
}

// Read file
void readFile(String name) {
  File file = SPIFFS.open(name, "r");
  if (!file) {
    Serial.print(F("Failed to open "));
    Serial.print(name);
    Serial.println(F(" for reading"));
  }

  Serial.println(F("File content:"));
  while (file.available()) {
    Serial.write(file.read());
  }

  file.close();
}

// Change current used key to the next one from used list
void getNextKeyFromFile(File keysFile) {
  byte b1, b2;
  for (byte i = 0; i < MFRC522::MF_KEY_SIZE; i++) {
    b1 = getNextByteFromFile(keysFile);
    b2 = getNextByteFromFile(keysFile);
    key.keyByte[i] = createHexFromBytes(b1, b2);
  }
  getNextByteFromFile(keysFile);
}

// Wrapper for checking read buffer
char getNextByteFromFile(File file) {
  if (file.available())
    return file.read();
}

// Helper function -> dumping byte buffers
void dumpByteArray(byte* buffer, byte bufferSize) {
  for (byte i = 0; i < bufferSize; i++) {
    Serial.print(buffer[i] < 0x10 ? " 0" : " ");
    Serial.print(buffer[i], HEX);
  }
}

// Hacky code time for timeout problems
void isTimeout(MFRC522::MIFARE_Key* key) {
  byte bufferATQA[2];
  byte bufferSize = sizeof(bufferATQA);
  
  if (timeoutFlag) {
    counter++;
    mfrc522.PICC_RequestA(bufferATQA, &(bufferSize));
    mfrc522.PICC_ReadCardSerial();
    if (counter%2 == 0) {                               // Problem occur only after two consecutive timeouts
      mfrc522.PCD_Authenticate(MFRC522::PICC_CMD_MF_AUTH_KEY_A, 0, key, &(mfrc522.uid));  // Fake auth to ommit 'neccesary' timeout
      mfrc522.PICC_RequestA(bufferATQA, &(bufferSize));
      mfrc522.PICC_ReadCardSerial();
    }
    counter %= 2;
  }
  else {
    counter = 0;
  }
}

// Function which translates key format from list to correct MIFARE_Key
unsigned char createHexFromBytes (byte b1, byte b2) {
  unsigned char finalHex;
  unsigned char c1, c2;

  c1 = createHexHelper(b1);
  c2 = createHexHelper(b2);
  finalHex = c1<<4 | c2;

  return finalHex;
}

// Helper function for creating hex values
byte createHexHelper(byte b) {
  if (b < 58 && b > 47) {
    return b - 48;
  }
  if (b < 71 && b > 64) {
    return b- 55;
  }
  Serial.print(F("Wrong value during createHexHelper: "));
  Serial.print(b);                                      // Printed when non standard byte is used
  return b;
}

// Wrapper with options
void bruteKeyMenu() {
  Serial.println(F("\nChoose an option:"));
  Serial.println(F("0 - Only sector 0"));
  Serial.println(F("1 - Full every sector scan"));
  Serial.println(F("2 - Choose which sector\n"));

  while (!Serial.available()){};                        // Waits while the user does not start data
  int op = (int)Serial.read();                          // Retrieves the chosen option
  
  while (Serial.available()) {                          // Remove all characters after option
    if (Serial.read() == '\n') break; 
    Serial.read();
  }

  op = op - 48;
  int sector;
  switch (op) {
    case 0:
      Serial.println(F("Chosen bruting sector 0"));
      bruteKeySector(0);
      break;

    case 1:
      Serial.println(F("Chosen bruting every sector"));
      bruteKeyFull();
      break;
      
    case 2:
      Serial.println(F("Choose sector:\n[0-15]"));
      while (!Serial.available()){};
      sector = Serial.parseInt();
      if (sector >= 0 && sector <= 15) {
        bruteKeySector(sector);
      }
      else {
        Serial.println(F("Wrong sector"));
        return;
      }
      break;

    default:
      Serial.println(F("Wrong option"));
      return;
  }  
}

// Bruting chosen sector
void bruteKeySector(int sector) {
  bool found = false;
  File defaultKeys = SPIFFS.open("/extended-std.keys"); // Hardcoded usage of default list
  
  if (!defaultKeys) {
    Serial.println(F("Failed to open file for reading"));
  }

  Serial.print(F("Starting bruting sector "));
  Serial.println(sector);
  while(defaultKeys.available()) {
    getNextKeyFromFile(defaultKeys);
    isTimeout(&key);                                    // Hacky code for timeout problem
    if (validateKey(&key, sector)) {
      timeoutFlag = false;
      foundKey();
      correctKeys[sector] = key;
      found = true;
      readChosenWrapper(correctKeys, sector, sector);   // Comment to speed up a little bit
      defaultKeys.close();
      return;
    }
    else {
      timeoutFlag = true;
    }
  }
  defaultKeys.close();
  
  if (!found) {
    Serial.println(F("Key not found"));
    return;
  }
  saveKeys(false, sector);
}

// Function bruting every sector at once
void bruteKeyFull() {
  bool found[MAX_SECTOR_AMOUNT] = {false};
  File defaultKeys = SPIFFS.open("/extended-std.keys"); // Hardcoded usage of default list
  
  if (!defaultKeys) {
    Serial.println(F("Failed to open file for reading"));
  }

  Serial.println(F("Starting full bruting"));
  while(defaultKeys.available()) {
    getNextKeyFromFile(defaultKeys);
    for (int i = 0; i < MAX_SECTOR_AMOUNT; i++) {
      if (found[i] == true) {
        continue;
      }
      isTimeout(&key);                                  // Hacky code for timeout problems
      if (validateKey(&key, i)) {
        timeoutFlag = false;
        foundKey();
        correctKeys[i] = key;
        found[i] = true;
        readChosenWrapper(correctKeys, i, i);           // Comment to speed up a little bit
        Serial.println();
      }
      else {
        timeoutFlag = true;
      }
    }
  }
  defaultKeys.close();

  for (byte i = 0; i < MAX_SECTOR_AMOUNT; i++) {
    if (found[i] == false) {
      Serial.print(F("Key for sector "));
      Serial.print(i);
      Serial.println(F(" not found. Using default value for file saving"));
      correctKeys[i] = defaultKey;
    }
  }

  saveKeys(true, 0);
}

// Found key information
void foundKey() {
  Serial.print(F("\nFound correct key: "));
  dumpByteArray(key.keyByte,MFRC522::MF_KEY_SIZE);
  Serial.println("\n");
}

// Validating correctness of the tested key
bool validateKey(MFRC522::MIFARE_Key* cKey, int sector) {
  // Authenticate using key A
  Serial.print(F("Authenticating using key: "));
  dumpByteArray(cKey->keyByte, MFRC522::MF_KEY_SIZE);
  Serial.print(F(" on sector "));
  Serial.println(sector);
  byte trailerBlock = sector * 4 + 3;
  
  status = (MFRC522::StatusCode)mfrc522.PCD_Authenticate(MFRC522::PICC_CMD_MF_AUTH_KEY_A, trailerBlock, cKey, &(mfrc522.uid));
  if (status != MFRC522::STATUS_OK) {
    Serial.print(F("PCD_Authenticate() failed: "));
    Serial.println(mfrc522.GetStatusCodeName(status));
    return false;
  }
  return true;
}

// Save bruteforced keys to memory
void saveKeys(bool allKeys, int sector) {
  String name = chooseFileName();
  File newFile = createNewFile(name);

  if (!newFile) {
    return;
  }

  if (allKeys) {
    for (byte i = 0; i < MAX_SECTOR_AMOUNT; i++) {
      saveToFile(newFile, correctKeys[i].keyByte, MFRC522::MF_KEY_SIZE);
    }
  }
  else {
    saveToFile(newFile, correctKeys[sector].keyByte, MFRC522::MF_KEY_SIZE);
  }
  newFile.close();
  
  Serial.print(F("File "));
  Serial.print(name);
  Serial.println(F(" saved"));
}

// Menu for cloning options
void cardCloneMenu() {
  Serial.println(F("\nChoose an option:"));
  Serial.println(F("0 - Copy data from card"));
  Serial.println(F("1 - Copy saved data to card"));
  Serial.println(F("2 - Load key (single) from file"));
  Serial.println(F("3 - Load keys (array) from file\n"));

  while (!Serial.available()){};                        // Waits while the user does not start data
  int op = (int)Serial.read();                          // Retrieves the chosen option
  
  while (Serial.available()) {                          // Remove all characters after option
    if (Serial.read() == '\n') break; 
    Serial.read();
  }

  op = op - 48;
  switch(op) {
    case 0:
      Serial.println(F("Chosen cloning TO MEMORY (0)"));
      cloneToMemory(correctKeys, &(mfrc522.uid));
      break;

    case 1:
      Serial.println(F("Chosen cloning FROM MEMORY (1)"));
      cloneFromMemory(correctKeys, &(mfrc522.uid));
      break;
      
    case 2:
      Serial.println(F("Chosen loading single key from file (2)"));
      loadSingleKey();
      break;
      
    case 3:
      Serial.println(F("Chosen loading array of keys from file (3)"));
      loadAllKeys();
      break;

    default:
      Serial.println(F("Wrong option"));
      return;   
  }
}

// Load single key to memory
void loadSingleKey() {
  String name = chooseFileName();
  File readFile = SPIFFS.open(name, "r");

  if (!readFile) {
    Serial.print(F("Failed to open file "));
    Serial.println(name);
    return;
  }

  while(readFile.available()) {
    getNextKeyFromFile(readFile);
  }
  readFile.close();

  Serial.println();
  Serial.println(F("Loading from file ended"));
}

// Load array of keys to memory
void loadAllKeys() {
  String name = chooseFileName();
  File readFile = SPIFFS.open(name, "r");

  if (!readFile) {
    Serial.print(F("Failed to open file "));
    Serial.println(name);
    return;
  }

  for (byte i = 0; i < MAX_SECTOR_AMOUNT; i++) {
    getNextKeyFromFile(readFile);
    Serial.println();
    dumpByteArray(key.keyByte, MFRC522::MF_KEY_SIZE);
    correctKeys[i] = key;
  }
  readFile.close();

  Serial.println();
  Serial.println(F("Loading from file ended"));
}

// Saving data from card with loaded keys to memory (file)
void cloneToMemory(MFRC522::MIFARE_Key cKeys[], MFRC522::Uid* uid) {
  byte no_of_sectors = MAX_SECTOR_AMOUNT;
  byte no_of_blocks = 4;
  byte buffer[18];
  byte blockAddr;
  byte firstBlock;
  byte byteCount;
  bool isSectorTrailer;

  String name = chooseFileName();

  File newFile = createNewFile(name);

  if (!newFile) {
    return;
  }
  for (int sector = 0; sector < no_of_sectors; sector++) {
    firstBlock = sector * no_of_blocks;
    isSectorTrailer = true;
    
    for (int blockOffset = 0; blockOffset < no_of_blocks; blockOffset++) {
      blockAddr = firstBlock + blockOffset;
      
      if (isSectorTrailer) {
        status = mfrc522.PCD_Authenticate(MFRC522::PICC_CMD_MF_AUTH_KEY_A, firstBlock, &cKeys[sector], uid);
        if (status != MFRC522::STATUS_OK) {
          Serial.print(F("PCD_Authenticate() failed: "));
          Serial.println(mfrc522.GetStatusCodeName(status));
          return;
        }
        isSectorTrailer = false;
      }

      byteCount = sizeof(buffer);
      status = mfrc522.MIFARE_Read(blockAddr, buffer, &byteCount);
      if (status != MFRC522::STATUS_OK) {
        Serial.print(F("MIFARE_Read() failed: "));
        Serial.println(mfrc522.GetStatusCodeName(status));
        continue;
      }

      saveToFile(newFile, buffer, MAX_SIZE_BLOCK);
    }
  }
  Serial.print(F("Successfuly saved data to file: "));
  Serial.println(name);
  newFile.close();
}


// Saving data from memory (chosen file) to actually used card
void cloneFromMemory(MFRC522::MIFARE_Key cKeys[], MFRC522::Uid* uid) {
  byte no_of_sectors = MAX_SECTOR_AMOUNT;
  byte no_of_blocks = 4;
  byte buffer[18];
  byte blockAddr;
  byte firstBlock;
  bool isSectorTrailer;
  byte b1, b2;

  String name = chooseFileName();

  File readFile = SPIFFS.open(name, "r");

  if (!readFile) {
    Serial.print(F("Failed to open file "));
    Serial.println(name);
    return;
  }
  for (int sector = 0; sector < no_of_sectors; sector++) {
    firstBlock = sector * no_of_blocks;
    isSectorTrailer = true;
    
    for (int blockOffset = 0; blockOffset < no_of_blocks; blockOffset++) {
      blockAddr = firstBlock + blockOffset;

      for (byte index = 0; index < MAX_SIZE_BLOCK; index++) {
        b1 = getNextByteFromFile(readFile);
        b2 = getNextByteFromFile(readFile);
        buffer[index] = createHexFromBytes(b1, b2);
      }
      getNextByteFromFile(readFile);

      // Easily modifiable code for choosing copied blocks
      switch(blockAddr) {
        case 0:
          Serial.println("Hardcoded ommiting of block 0");
          break;
        case 3:
        case 7:
        case 11:
        case 15:
        case 19:
        case 23:
        case 27:
        case 31:
        case 35:
        case 39:
        case 43:
        case 47:
        case 51:
        case 55:
        case 59:
        case 63:
          if (!writeKeySector(&cKeys[sector], &cKeys[sector], blockAddr, buffer)) {
            Serial.print(F("Something went wrong when writing inside key block: "));
            Serial.println(blockAddr);
            return;
          }
          break;

        default:
          if (!writeData(&cKeys[sector], &cKeys[sector], blockAddr, buffer)) {
            Serial.print(F("Something went wrong when writing inside block: "));
            Serial.println(blockAddr);
            return;
          }
          break;
      }
    }
  }
  readFile.close();
  Serial.println(F("Succesfully endend cloning data to tag"));
}

// Creating new file
File createNewFile(String name) {
  if (SPIFFS.exists(name)) {
    Serial.print(F("Overwriting "));
    Serial.println(name);
    SPIFFS.remove(name);
  }
  File newFile = SPIFFS.open(name, "a");
  if (!newFile) {
    Serial.println(F("Error opening/creating file"));
    return newFile;
  }
  
  Serial.print(F("Created file "));
  Serial.println(name);
  return newFile;
}

// Choosing file name when creating file
String chooseFileName() {
  Serial.println();
  Serial.println(F("Give file name: "));
  
  while (!Serial.available()){};
  String buffer = Serial.readString();
  buffer.trim();
  
  Serial.print(F("Chosen name: "));
  Serial.println(buffer);
  return buffer;
}

// Saving to file
void saveToFile(File file, byte toSave[], byte size) {  
  for (byte i = 0; i < size; i++) {
    if(toSave[i] < 0x10) {
      file.print("0");
    }
    file.print(toSave[i], HEX);
    }

  file.print('\n');
}

// Listing files
void listFiles(String filename, int level) {
  Serial.print(F("Listing directory "));
  Serial.println(filename);

  File dir = SPIFFS.open(filename);
  if (!dir) {
    Serial.println(F("Failed to open directory"));
    return;
  }
  if (!dir.isDirectory()) {
    Serial.println(F("This is not directory"));
    return;
  }

  File next = dir.openNextFile();
  while (next) {
    if (next.isDirectory()) {
      Serial.print(F("  DIR : "));
      Serial.println(next.name());
      if (level) {
        listFiles(next.name(), level - 1);
      }
    }
    else {
      Serial.print(F("  FILE: "));
      Serial.print(next.name());
      Serial.print(F("\tSIZE: "));
      Serial.println(next.size());
    }
    next = dir.openNextFile();
  }
}

// Default write function
bool writeData(MFRC522::MIFARE_Key* keyA, MFRC522::MIFARE_Key* keyB, int block, byte toWrite[]) {
  byte buffer[18];
  byte size = sizeof(buffer);

  // Authenticate using key A
  status = (MFRC522::StatusCode)mfrc522.PCD_Authenticate(MFRC522::PICC_CMD_MF_AUTH_KEY_A, block, keyA, &(mfrc522.uid));
  
  if (status != MFRC522::STATUS_OK) {
    Serial.print(F("PCD_Authenticate() failed: "));
    Serial.println(mfrc522.GetStatusCodeName(status));
    return false;
  }

  // Read data from the block
  Serial.print(F("Reading data from block ")); Serial.print(block);
  Serial.println(F(" ..."));
  status = (MFRC522::StatusCode) mfrc522.MIFARE_Read(block, buffer, &size);
  
  if (status != MFRC522::STATUS_OK) {
    Serial.print(F("MIFARE_Read() failed: "));
    Serial.println(mfrc522.GetStatusCodeName(status));
    return false;
  }
  
  Serial.print(F("Data in block ")); Serial.print(block); Serial.println(F(":"));
  dumpByteArray(buffer, MAX_SIZE_BLOCK); Serial.println();
  Serial.println();

  // Authenticate using key B
  status = (MFRC522::StatusCode)mfrc522.PCD_Authenticate(MFRC522::PICC_CMD_MF_AUTH_KEY_B, block, keyB, &(mfrc522.uid));
  
  if (status != MFRC522::STATUS_OK) {
    Serial.print(F("PCD_Authenticate() failed: "));
    Serial.println(mfrc522.GetStatusCodeName(status));
    return false;
  }
 
  // Write data to the block
  Serial.print(F("Writing data into block ")); Serial.print(block);
  Serial.println(F(" ..."));
  status = (MFRC522::StatusCode) mfrc522.MIFARE_Write(block, toWrite, MAX_SIZE_BLOCK);
  
  if (status != MFRC522::STATUS_OK) {
    Serial.print(F("MIFARE_Write() failed: "));
    Serial.println(mfrc522.GetStatusCodeName(status));
    return false;
  }
  Serial.println();

  // Read data from the block (again, should now be what we have written)
  Serial.print(F("Checking data from block ")); Serial.print(block);
  Serial.println(F(" ..."));
  status = (MFRC522::StatusCode)mfrc522.MIFARE_Read(block, buffer, &size);
  
  if (status != MFRC522::STATUS_OK) {
    Serial.print(F("MIFARE_Read() failed: "));
    Serial.println(mfrc522.GetStatusCodeName(status));
    return false;
  }
  
  Serial.print(F("Everything alright in block ")); Serial.print(block);
  Serial.println();
  return true;  
}

// Specific write function for block with keys
bool writeKeySector(MFRC522::MIFARE_Key* oldKeyA, MFRC522::MIFARE_Key* oldKeyB, int trailerBlock, byte toWrite[]) {
  byte buffer[18];
  byte size = sizeof(buffer);
  MFRC522::MIFARE_Key newKey;

  // Authenticate using key A
  status = (MFRC522::StatusCode)mfrc522.PCD_Authenticate(MFRC522::PICC_CMD_MF_AUTH_KEY_A, trailerBlock, oldKeyA, &(mfrc522.uid));
  
  if (status != MFRC522::STATUS_OK) {
    Serial.print(F("PCD_Authenticate() failed: "));
    Serial.println(mfrc522.GetStatusCodeName(status));
   return false;
  }

  // Read data from the block
  Serial.print(F("Reading data from block ")); Serial.print(trailerBlock);
  Serial.println(F(" ..."));
  status = (MFRC522::StatusCode) mfrc522.MIFARE_Read(trailerBlock, buffer, &size);
  
  if (status != MFRC522::STATUS_OK) {
    Serial.print(F("MIFARE_Read() failed: "));
    Serial.println(mfrc522.GetStatusCodeName(status));
   return false;
  }
  
  Serial.print(F("Data in block ")); Serial.print(trailerBlock); Serial.println(F(":"));
  dumpByteArray(buffer, MAX_SIZE_BLOCK); Serial.println();
  Serial.println();

  // Authenticate using key B
  status = (MFRC522::StatusCode)mfrc522.PCD_Authenticate(MFRC522::PICC_CMD_MF_AUTH_KEY_B, trailerBlock, oldKeyB, &(mfrc522.uid));
  
  if (status != MFRC522::STATUS_OK) {
    Serial.print(F("PCD_Authenticate() failed: "));
    Serial.println(mfrc522.GetStatusCodeName(status));
   return false;
  }

  // Key A == Key B in our case
  // We want to have 6:4:6 (KeyA:AccessBits:KeyB)
  for (byte i = 0; i < MFRC522::MF_KEY_SIZE; i++) {
    buffer[i] = toWrite[i+10];
    buffer[i+10] = toWrite[i+10];
    newKey.keyByte[i] = toWrite[i+10];
  }
  for (byte i = 0; i < 4; i++) {
    buffer[i+6] = toWrite[i+6];
  }

  // Write data to the block
  Serial.print(F("Writing data into block ")); Serial.print(trailerBlock);
  Serial.println(F(" ..."));
  status = (MFRC522::StatusCode) mfrc522.MIFARE_Write(trailerBlock, buffer, MAX_SIZE_BLOCK);
  
  if (status != MFRC522::STATUS_OK) {
    Serial.print(F("MIFARE_Write() failed: "));
    Serial.println(mfrc522.GetStatusCodeName(status));
    return false;
  }
  Serial.println();

  // Read data from the block (again, should now be what we have written)
  Serial.print(F("Checking data from block ")); Serial.print(trailerBlock);
  Serial.println(F(" ..."));
  status = (MFRC522::StatusCode)mfrc522.MIFARE_Read(trailerBlock, buffer, &size);
  
  if (status != MFRC522::STATUS_OK) {
    Serial.print(F("MIFARE_Read() failed: "));
    Serial.println(mfrc522.GetStatusCodeName(status));
    return false;
  }
  
  Serial.print(F("Everything alright in block ")); Serial.print(trailerBlock);
  Serial.println();
  return true;  
}

// Printing keys from memory
void listLoadedKeys() {
  for (byte i = 0; i < MAX_SECTOR_AMOUNT; i++) {
    dumpByteArray(correctKeys[i].keyByte, MFRC522::MF_KEY_SIZE);
    Serial.println();
  }
}

// Reading file content
void chooseFileToRead() {
  Serial.println("Give file name: ");

  while (!Serial.available()){};
  String buffer = Serial.readString();
  buffer.trim();

  Serial.print(F("Chosen file: "));
  Serial.println(buffer);

  readFile(buffer);
}

// Main menu
int menu()
{
  Serial.println(F("\nChoose an option:"));
  Serial.println(F("0 - Reading data (default keys + for different PICC types"));
  Serial.println(F("1 - Writing data"));
  Serial.println(F("2 - Change key"));
  Serial.println(F("3 - Print keys from list"));
  Serial.println(F("4 - Brute keys"));
  Serial.println(F("5 - Print full data from card (using loaded keys)"));
  Serial.println(F("6 - Clone card"));
  Serial.println(F("7 - List files"));
  Serial.println(F("8 - List loaded keys"));
  Serial.println(F("9 - Print file content\n"));

  while (!Serial.available()){};                        // Waits while the user does not start data
  int op = (int)Serial.read();                          // Retrieves the chosen option
  
  while (Serial.available()) {                          // Remove all characters after option
    if (Serial.read() == '\n') break; 
    Serial.read();
  }
  
  return (op - 48);                                     // Subtract 48 from read value, 48 is the ascii zero
}

// List of options for menu
void menuOptions(int op) {
  Serial.println();
  switch(op) {
    case 0:
      Serial.println(F("Chosen reading full data (PICC sensitive) (0)"));
      readFullData(&key);
      break;
      
    case 1:
      Serial.println(F("Chosen writing data to tag (1)"));
      writingData();
      break;
      
    case 2:
      Serial.println(F("Chosen changing key (2)"));
      changeKey();
      break;
      
    case 3:
      Serial.println(F("Printing content of /extended-std.keys (3)"));
      readFile("/extended-std.keys");
      break;
      
    case 4:
      Serial.println(F("Chosen bruting menu (4)"));
      bruteKeyMenu();
      break;
      
    case 5:
      Serial.println(F("Chosen full reading using loaded keys (5)"));
      readChosenWrapper(correctKeys, 0, 15);
      break;
      
    case 6:
      Serial.println(F("Chosen cloning menu (6)"));
      cardCloneMenu();
      break;
      
    case 7:
      Serial.println(F("Chosen listing files (7)"));
      listFiles("/", 0);
      break;
      
    case 8:
      Serial.println(F("Chosen listing loaded keys (8)"));
      listLoadedKeys();
      break;
      
    case 9:
      Serial.println(F("Chosen file reading (9)"));
      chooseFileToRead();
      break;
      
    default:
      Serial.println(F("Incorrect option!"));
      return;
  }
}
