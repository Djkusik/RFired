/*
 * Fragments of code taken from public domain MFRC522 example in https://github.com/miguelbalboa/rfid
 */

// #include <EEPROM.h>     // We are going to read and write PICC's UIDs from/to EEPROM
#include <SPI.h>        // RC522 Module uses SPI protocol
#include <MFRC522.h>    // Library for Mifare RC522 Devices
// #include "mbedtls/md.h" // SHA

#define DEBUG
#define MAGIC_NUMBER_SIZE 4
#define KEY_SIZE 6
#define TAG_UID_SIZE 4
#define BLOCK_SIZE 16

// #define COMMON_ANODE
#ifdef COMMON_ANODE
#define LED_ON LOW
#define LED_OFF HIGH
#else
#define LED_ON HIGH
#define LED_OFF LOW
#endif

// Set pins
#define RED_LED 17
#define GREEN_LED 16
#define BLUE_LED 4
#define WIPE_BUTTON 2

// Create MFRC522 instance
#define SS_PIN 5
#define RST_PIN 22
MFRC522 mfrc(SS_PIN, RST_PIN);

byte masterTag[TAG_UID_SIZE];
byte magicNumber[MAGIC_NUMBER_SIZE];
MFRC522::MIFARE_Key key;

uint8_t readStatus;
byte outsideTag[TAG_UID_SIZE];
byte outsideData[BLOCK_SIZE + 2];       // + 2 for internal MIFARE_Read state
byte outsideMagicNumber[MAGIC_NUMBER_SIZE];

void setup() {
  pinMode(RED_LED, OUTPUT);
  pinMode(GREEN_LED, OUTPUT);
  pinMode(BLUE_LED, OUTPUT);
  pinMode(WIPE_BUTTON, INPUT_PULLUP);

  digitalWrite(RED_LED, LED_OFF);
  digitalWrite(GREEN_LED, LED_OFF);
  digitalWrite(BLUE_LED, LED_OFF);

  Serial.begin(9600);
  SPI.begin();
  mfrc.PCD_Init();

  // Setting Antenna Gain to max will increase reading distance
  // mfrc.PCD_SetAntennaGain(mfrc.RxGain_max);

  Serial.println(F("Initializing access control system:"));
  showReaderDetails();

  setKey();
  setMagicNumber();
  if (masterTagDefined()) {
    loadMasterTagFromMemory();
  } else {
    defineMasterTag();
  }
  
  Serial.println("");
  showDebugInfo();
  Serial.println(F("-------------------"));
  Serial.println(F("Everything is ready"));
  Serial.println(F("Waiting for tags"));
  cycleLeds();
}

void showReaderDetails() {
  mfrc.PCD_DumpVersionToSerial();
//  // Get the MFRC522 software version
//  byte v = mfrc.PCD_ReadRegister(mfrc.VersionReg);
//  Serial.print(F("MFRC522 Software Version: 0x"));
//  Serial.print(v, HEX);
//  if (v == 0x91)
//    Serial.print(F(" = v1.0"));
//  else if (v == 0x92)
//    Serial.print(F(" = v2.0"));
//  else
//    Serial.print(F(" (unknown),probably a chinese clone?"));
//  Serial.println("");
//  
//  // When 0x00 or 0xFF is returned, communication probably failed
//  if ((v == 0x00) || (v == 0xFF)) {
//    Serial.println(F("WARNING: Communication failure, is the MFRC522 properly connected?"));
//    Serial.println(F("SYSTEM HALTED: Check connections."));
//    // Visualize system is halted
//    digitalWrite(GREEN_LED, LED_OFF);
//    digitalWrite(BLUE_LED, LED_OFF);
//    digitalWrite(RED_LED, LED_ON);
//    while (true);                     // do not go further
//  }
}

void setKey() {
  for (byte i = 0; i < KEY_SIZE; i++) {
    key.keyByte[i] = 0xFF;
  }
}

void setMagicNumber() {
  magicNumber[0] = 0xDE;
  magicNumber[1] = 0xAD;
  magicNumber[2] = 0xBE;
  magicNumber[3] = 0xEF;
}

bool masterTagDefined() {
  // TODO
  return false;
}

void loadMasterTagFromMemory() {
  Serial.println("Loading master tag from memory");
  // TODO: EEPROM
}

void defineMasterTag() {
  Serial.println("No master tag defined, scan new master tag");
  do {
    digitalWrite(BLUE_LED, LED_ON);
    delay(200);
    digitalWrite(BLUE_LED, LED_OFF);
    delay(200);
    readStatus = readTagUID();
    mfrc.PICC_HaltA();
  } while (!readStatus);

  for (int i = 0; i < TAG_UID_SIZE; i++) {
    masterTag[i] = outsideTag[i];
  }

  // TODO: EEPROM persistence
  Serial.println("New master tag defined");
}

uint8_t readTagUID() {
  if (!mfrc.PICC_IsNewCardPresent())
    return 0;
  if (!mfrc.PICC_ReadCardSerial())
    return 0;
    
  #ifdef DEBUG
  mfrc.PICC_DumpDetailsToSerial(&(mfrc.uid));
  #endif
  
  Serial.print("Scanned PICC's UID: 0x");
  for (int i = 0; i < TAG_UID_SIZE; i++) {
    outsideTag[i] = mfrc.uid.uidByte[i];
    Serial.print(outsideTag[i], HEX);
  }
  Serial.println("");
  
  return 1;
}

void showDebugInfo() {
  #ifdef DEBUG
  Serial.print("Key: 0x");
  for (int i = 0; i < KEY_SIZE; i++) {
    Serial.print(key.keyByte[i], HEX);
  }
  Serial.println("");
  Serial.print("Magic number: 0x");
  for (int i = 0; i < MAGIC_NUMBER_SIZE; i++) {
    Serial.print(magicNumber[i], HEX);
  }
  Serial.println("");
  Serial.print("Master tag UID: 0x");
  for (int i = 0; i < TAG_UID_SIZE; i++) {
    Serial.print(masterTag[i], HEX);
  }
  Serial.println("");
  #endif
}

void cycleLeds() {
  digitalWrite(RED_LED, LED_ON);
  digitalWrite(GREEN_LED, LED_OFF);
  digitalWrite(BLUE_LED, LED_OFF);
  delay(200);
  digitalWrite(RED_LED, LED_OFF);
  digitalWrite(GREEN_LED, LED_ON);
  digitalWrite(BLUE_LED, LED_OFF);
  delay(200);
  digitalWrite(RED_LED, LED_OFF);
  digitalWrite(GREEN_LED, LED_OFF);
  digitalWrite(BLUE_LED, LED_ON);
  delay(200);
}

void loop() {
  digitalWrite(RED_LED, LED_OFF);
  digitalWrite(GREEN_LED, LED_OFF);
  digitalWrite(BLUE_LED, LED_ON);
  
  do {
    readStatus = readTagUID();
  } while (!readStatus);

  if (masterTagScanned()) {
    mfrc.PICC_HaltA();
    masterMode();
  } else {
    verificationMode();
  }
}

bool masterTagScanned() {
  for (int i = 0; i < TAG_UID_SIZE; i++) {
    if (outsideTag[i] != masterTag[i]) {
      return false;
    }
    return true;
  }
}

void masterMode() {
  Serial.println("Entering master mode");
  Serial.println("Scan new tags to program them");
  Serial.println("Scan master tag again to exit");

  while (true) {
    digitalWrite(RED_LED, LED_OFF);
    digitalWrite(GREEN_LED, LED_OFF);
    do {
      digitalWrite(BLUE_LED, LED_ON);
      delay(200);
      digitalWrite(BLUE_LED, LED_OFF);
      delay(200);
      readStatus = readTagUID();
    } while (!readStatus);

    if (masterTagScanned()) {
      mfrc.PICC_HaltA();
      Serial.println("Leaving master mode");
      return;
    } else {
      Serial.println("Programming new tag");
      programTag();
    }
  }
}

void programTag() {
  MFRC522::StatusCode status;
  byte dataBlockAddress = 4;
  byte dataToWrite[BLOCK_SIZE];
  byte dataLength = BLOCK_SIZE;

  for (int i = 0; i < MAGIC_NUMBER_SIZE; i++) {
    dataToWrite[i] = magicNumber[i];
  }
  for (int i = MAGIC_NUMBER_SIZE; i < BLOCK_SIZE; i++) {
    dataToWrite[i] = 0x00;
  }

  if (!authenticate(dataBlockAddress)) {
    mfrc.PICC_HaltA();
    return;
  }

  status = mfrc.MIFARE_Write(dataBlockAddress, dataToWrite, dataLength);
  if (status != MFRC522::STATUS_OK) {
    Serial.print("Writing failed: ");
    Serial.println(mfrc.GetStatusCodeName(status));
    digitalWrite(GREEN_LED, LED_OFF);
    digitalWrite(RED_LED, LED_ON);
    digitalWrite(BLUE_LED, LED_OFF);
  } else {
    Serial.println("Successfully programmed new tag");
    digitalWrite(GREEN_LED, LED_ON);
    digitalWrite(RED_LED, LED_OFF);
    digitalWrite(BLUE_LED, LED_OFF);
  }
  delay(2000);

  mfrc.PICC_HaltA();
  mfrc.PCD_StopCrypto1();
}

bool authenticate(byte dataBlockAddress) {
  MFRC522::StatusCode status;

  status = mfrc.PCD_Authenticate(
    MFRC522::PICC_CMD_MF_AUTH_KEY_A,
    dataBlockAddress,
    &key,
    &(mfrc.uid)
  );

  if (status != MFRC522::STATUS_OK) {
    Serial.print("Authentication failed: ");
    Serial.println(mfrc.GetStatusCodeName(status));
    return false;
  }

  return true;
}

void verificationMode() {
  byte dataBlockAddress = 4;
  byte dataLength = 18;

  if (!authenticate(dataBlockAddress)) {
    mfrc.PICC_HaltA();
    return;
  }

  if (!readOutsideData(dataBlockAddress, &dataLength)) {
    return;
  }

  for (int i = 0; i < MAGIC_NUMBER_SIZE; i++) {
    outsideMagicNumber[i] = outsideData[i];
  }

  if (validateMagicNumber()) {
    acceptTag();
  } else {
    rejectTag();
  }
}

bool readOutsideData(byte dataBlockAddress, byte *dataLength) {
  MFRC522::StatusCode status;
  
  status = mfrc.MIFARE_Read(dataBlockAddress, outsideData, dataLength);
  if (status != MFRC522::STATUS_OK) {
    Serial.print("Reading failed: ");
    Serial.println(mfrc.GetStatusCodeName(status));
    return false;
  }

  #ifdef DEBUG
  Serial.println("Read outside data: ");
  for (int i = 0; i < BLOCK_SIZE; i++) {
    Serial.print(outsideData[i], HEX);
    Serial.print(" ");
  }
  Serial.println("");
  Serial.print(*dataLength);
  Serial.println(" bytes read");
  #endif

  mfrc.PICC_HaltA();
  mfrc.PCD_StopCrypto1();
  return true;
}

bool validateMagicNumber() {
  for (int i = 0; i < MAGIC_NUMBER_SIZE; i++) {
    if (outsideMagicNumber[i] != magicNumber[i]) {
      return false;
    }
  }
  return true;
}

void acceptTag() {
  Serial.println("Tag accepted!");
  digitalWrite(GREEN_LED, LED_ON);
  digitalWrite(RED_LED, LED_OFF);
  digitalWrite(BLUE_LED, LED_OFF);
  delay(2000);
}

void rejectTag() {
  Serial.println("Tag rejected!");
  digitalWrite(GREEN_LED, LED_OFF);
  digitalWrite(RED_LED, LED_ON);
  digitalWrite(BLUE_LED, LED_OFF);
  
  #ifdef DEBUG
  Serial.print("Expected magic number: 0x");
  for (int i = 0; i < MAGIC_NUMBER_SIZE; i++) {
    Serial.print(magicNumber[i], HEX);
  }
  Serial.print(", got: 0x");
  for (int i = 0; i < MAGIC_NUMBER_SIZE; i++) {
    Serial.print(outsideMagicNumber[i], HEX);
  }
  Serial.println("");
  #endif
  
  delay(2000);
}

