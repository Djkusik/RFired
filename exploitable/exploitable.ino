/*
 * Fragments of code taken from public domain MFRC522 example in https://github.com/miguelbalboa/rfid
 */

#include <SPI.h>        // RC522 Module uses SPI protocol
#include <MFRC522.h>    // Library for Mifare RC522 Devices
#include <Preferences.h>

#define DEBUG
#define MAGIC_NUMBER_SIZE 4
#define KEY_SIZE 6
#define TAG_UID_SIZE 4
#define BLOCK_SIZE 16

// #define COMMON_ANODE
#ifdef COMMON_ANODE
#define LED_ON LOW
#define LED_OFF HIGH
#else
#define LED_ON HIGH
#define LED_OFF LOW
#endif

// Set pins
#define RED_LED 17
#define GREEN_LED 16
#define BLUE_LED 4
#define WIPE_BUTTON 2

// Create MFRC522 instance
#define SS_PIN 5
#define RST_PIN 22
MFRC522 mfrc(SS_PIN, RST_PIN);

byte masterTag[TAG_UID_SIZE];
byte magicNumber[MAGIC_NUMBER_SIZE];
MFRC522::MIFARE_Key key;

Preferences preferences;
uint8_t readStatus;
byte outsideTag[TAG_UID_SIZE];
byte outsideData[BLOCK_SIZE + 2];       // + 2 for internal MIFARE_Read state
byte outsideMagicNumber[MAGIC_NUMBER_SIZE];

void setup() {
  pinMode(RED_LED, OUTPUT);
  pinMode(GREEN_LED, OUTPUT);
  pinMode(BLUE_LED, OUTPUT);
  pinMode(WIPE_BUTTON, INPUT_PULLUP);

  digitalWrite(RED_LED, LED_OFF);
  digitalWrite(GREEN_LED, LED_OFF);
  digitalWrite(BLUE_LED, LED_OFF);

  Serial.begin(9600);
  SPI.begin();
  mfrc.PCD_Init();
  preferences.begin("exploitable", false);

  // Setting Antenna Gain to max will increase reading distance
  // mfrc.PCD_SetAntennaGain(mfrc.RxGain_max);

  Serial.println(F("Initializing access control system:"));
  showReaderDetails();

  if (wipeButtonPressed()) {
    wipeMemoryWithDelay();
  }

  setKey();
  setMagicNumber();
  if (masterTagDefined()) {
    loadMasterTagFromMemory();
  } else {
    defineMasterTag();
  }
  preferences.end();
  
  Serial.println("");
  showDebugInfo();
  Serial.println(F("-------------------"));
  Serial.println(F("Everything is ready"));
  Serial.println(F("Waiting for tags"));
  cycleLeds();
}

void showReaderDetails() {
  // Like mfrc.PCD_DumpVersionToSerial(); but with LED support
  // Get the MFRC522 firmware version
  byte v = mfrc.PCD_ReadRegister(mfrc.VersionReg);
  Serial.print("Firmware Version: 0x");
  Serial.print(v, HEX);
  // Lookup which version
  switch(v) {
    case 0x88: Serial.println(" = (clone)");  break;
    case 0x90: Serial.println(" = v0.0");     break;
    case 0x91: Serial.println(" = v1.0");     break;
    case 0x92: Serial.println(" = v2.0");     break;
    case 0x12: Serial.println(" = counterfeit chip");     break;
    default:   Serial.println(" = (unknown)");
  }
  
  // When 0x00 or 0xFF is returned, communication probably failed
  if ((v == 0x00) || (v == 0xFF)) {
    Serial.println("WARNING: Communication failure, is the MFRC522 properly connected?");
    Serial.println("SYSTEM HALTED: Check connections.");
    // Visualize system is halted
    digitalWrite(GREEN_LED, LED_OFF);
    digitalWrite(BLUE_LED, LED_OFF);
    digitalWrite(RED_LED, LED_ON);
    while (true);                     // do not go further
  }
}

bool wipeButtonPressed() {
  return (digitalRead(WIPE_BUTTON) == LOW);
}

void wipeMemoryWithDelay() {
  Serial.println("Wipe button pressed");
  Serial.println("Hold it for 5 seconds to erase internal memory");
  if (monitorWipeButton(5000)) {
    wipeMemory();
    Serial.println("Internal memory erased");
  } else {
    Serial.println("Erasing memory aborted");
  }
}

bool monitorWipeButton(uint32_t interval) {
  uint32_t startTime = (uint32_t) millis();
  while ((uint32_t) millis() - startTime < interval) {
    digitalWrite(RED_LED, LED_ON);
    delay(100);
    digitalWrite(RED_LED, LED_OFF);
    delay(100);
    if (!wipeButtonPressed()) {
      return false;
    }
  }
  return true;
}

void wipeMemory() {
  preferences.clear();
}

void setKey() {
  for (byte i = 0; i < KEY_SIZE; i++) {
    key.keyByte[i] = 0xFF;
  }
}

void setMagicNumber() {
  magicNumber[0] = 0xDE;
  magicNumber[1] = 0xAD;
  magicNumber[2] = 0xBE;
  magicNumber[3] = 0xEF;
}

bool masterTagDefined() {
  char dirtyByte = preferences.getChar("dirty");
  if (dirtyByte) {
    return true;
  }
  return false;
}

void loadMasterTagFromMemory() {
  Serial.println("Loading master tag from memory");
  size_t memoryTagSize = preferences.getBytes("masterTag", masterTag, TAG_UID_SIZE);
  if (memoryTagSize != TAG_UID_SIZE) {
    Serial.println("Error while reading master tag from memory. Please define it again");
  }
}

void defineMasterTag() {
  Serial.println("No master tag defined, scan new master tag");
  do {
    digitalWrite(BLUE_LED, LED_ON);
    delay(200);
    digitalWrite(BLUE_LED, LED_OFF);
    delay(200);
    readStatus = readTagUID();
    mfrc.PICC_HaltA();
  } while (!readStatus);

  for (int i = 0; i < TAG_UID_SIZE; i++) {
    masterTag[i] = outsideTag[i];
  }

  size_t bytesWritten = preferences.putBytes("masterTag", masterTag, TAG_UID_SIZE);
  if (bytesWritten != TAG_UID_SIZE) {
    Serial.println("Error while writing master tag to memory. Please define it again");
  } else {
    preferences.putChar("dirty", 0xFF);
  }
  Serial.println("New master tag defined");
}

uint8_t readTagUID() {
  if (!mfrc.PICC_IsNewCardPresent())
    return 0;
  if (!mfrc.PICC_ReadCardSerial())
    return 0;
    
  #ifdef DEBUG
  mfrc.PICC_DumpDetailsToSerial(&(mfrc.uid));
  #endif
  
  Serial.print("Scanned PICC's UID: 0x");
  for (int i = 0; i < TAG_UID_SIZE; i++) {
    outsideTag[i] = mfrc.uid.uidByte[i];
    Serial.print(outsideTag[i], HEX);
  }
  Serial.println("");
  
  return 1;
}

void showDebugInfo() {
  #ifdef DEBUG
  Serial.print("Key: 0x");
  for (int i = 0; i < KEY_SIZE; i++) {
    Serial.print(key.keyByte[i], HEX);
  }
  Serial.println("");
  Serial.print("Magic number: 0x");
  for (int i = 0; i < MAGIC_NUMBER_SIZE; i++) {
    Serial.print(magicNumber[i], HEX);
  }
  Serial.println("");
  Serial.print("Master tag UID: 0x");
  for (int i = 0; i < TAG_UID_SIZE; i++) {
    Serial.print(masterTag[i], HEX);
  }
  Serial.println("");
  #endif
}

void cycleLeds() {
  digitalWrite(RED_LED, LED_ON);
  digitalWrite(GREEN_LED, LED_OFF);
  digitalWrite(BLUE_LED, LED_OFF);
  delay(200);
  digitalWrite(RED_LED, LED_OFF);
  digitalWrite(GREEN_LED, LED_ON);
  digitalWrite(BLUE_LED, LED_OFF);
  delay(200);
  digitalWrite(RED_LED, LED_OFF);
  digitalWrite(GREEN_LED, LED_OFF);
  digitalWrite(BLUE_LED, LED_ON);
  delay(200);
}

void loop() {
  digitalWrite(RED_LED, LED_OFF);
  digitalWrite(GREEN_LED, LED_OFF);
  digitalWrite(BLUE_LED, LED_ON);
  
  do {
    readStatus = readTagUID();
  } while (!readStatus);

  if (masterTagScanned()) {
    mfrc.PICC_HaltA();
    masterMode();
  } else {
    verificationMode();
  }
}

bool masterTagScanned() {
  for (int i = 0; i < TAG_UID_SIZE; i++) {
    if (outsideTag[i] != masterTag[i]) {
      return false;
    }
    return true;
  }
}

void masterMode() {
  Serial.println("Entering master mode");
  Serial.println("Scan new tags to program them");
  Serial.println("Scan master tag again to exit");

  while (true) {
    digitalWrite(RED_LED, LED_OFF);
    digitalWrite(GREEN_LED, LED_OFF);
    do {
      digitalWrite(BLUE_LED, LED_ON);
      delay(200);
      digitalWrite(BLUE_LED, LED_OFF);
      delay(200);
      readStatus = readTagUID();
    } while (!readStatus);

    if (masterTagScanned()) {
      mfrc.PICC_HaltA();
      Serial.println("Leaving master mode");
      return;
    } else {
      Serial.println("Programming new tag");
      programTag();
    }
  }
}

void programTag() {
  MFRC522::StatusCode status;
  byte dataBlockAddress = 4;
  byte dataToWrite[BLOCK_SIZE];
  byte dataLength = BLOCK_SIZE;

  for (int i = 0; i < MAGIC_NUMBER_SIZE; i++) {
    dataToWrite[i] = magicNumber[i];
  }
  for (int i = MAGIC_NUMBER_SIZE; i < BLOCK_SIZE; i++) {
    dataToWrite[i] = 0x00;
  }

  if (!authenticate(dataBlockAddress)) {
    mfrc.PICC_HaltA();
    return;
  }

  status = mfrc.MIFARE_Write(dataBlockAddress, dataToWrite, dataLength);
  if (status != MFRC522::STATUS_OK) {
    Serial.print("Writing failed: ");
    Serial.println(mfrc.GetStatusCodeName(status));
    digitalWrite(GREEN_LED, LED_OFF);
    digitalWrite(RED_LED, LED_ON);
    digitalWrite(BLUE_LED, LED_OFF);
  } else {
    Serial.println("Successfully programmed new tag");
    digitalWrite(GREEN_LED, LED_ON);
    digitalWrite(RED_LED, LED_OFF);
    digitalWrite(BLUE_LED, LED_OFF);
  }
  delay(2000);

  mfrc.PICC_HaltA();
  mfrc.PCD_StopCrypto1();
}

bool authenticate(byte dataBlockAddress) {
  MFRC522::StatusCode status;

  status = mfrc.PCD_Authenticate(
    MFRC522::PICC_CMD_MF_AUTH_KEY_A,
    dataBlockAddress,
    &key,
    &(mfrc.uid)
  );

  if (status != MFRC522::STATUS_OK) {
    Serial.print("Authentication failed: ");
    Serial.println(mfrc.GetStatusCodeName(status));
    return false;
  }

  return true;
}

void verificationMode() {
  byte dataBlockAddress = 4;
  byte dataLength = 18;

  if (!authenticate(dataBlockAddress)) {
    mfrc.PICC_HaltA();
    return;
  }

  if (!readOutsideData(dataBlockAddress, &dataLength)) {
    return;
  }

  for (int i = 0; i < MAGIC_NUMBER_SIZE; i++) {
    outsideMagicNumber[i] = outsideData[i];
  }

  if (validateMagicNumber()) {
    acceptTag();
  } else {
    rejectTag();
  }
}

bool readOutsideData(byte dataBlockAddress, byte *dataLength) {
  MFRC522::StatusCode status;
  
  status = mfrc.MIFARE_Read(dataBlockAddress, outsideData, dataLength);
  if (status != MFRC522::STATUS_OK) {
    Serial.print("Reading failed: ");
    Serial.println(mfrc.GetStatusCodeName(status));
    return false;
  }

  #ifdef DEBUG
  Serial.println("Read outside data: ");
  for (int i = 0; i < BLOCK_SIZE; i++) {
    Serial.print(outsideData[i], HEX);
    Serial.print(" ");
  }
  Serial.println("");
  Serial.print(*dataLength);
  Serial.println(" bytes read");
  #endif

  mfrc.PICC_HaltA();
  mfrc.PCD_StopCrypto1();
  return true;
}

bool validateMagicNumber() {
  for (int i = 0; i < MAGIC_NUMBER_SIZE; i++) {
    if (outsideMagicNumber[i] != magicNumber[i]) {
      return false;
    }
  }
  return true;
}

void acceptTag() {
  Serial.println("Tag accepted!");
  digitalWrite(GREEN_LED, LED_ON);
  digitalWrite(RED_LED, LED_OFF);
  digitalWrite(BLUE_LED, LED_OFF);
  delay(2000);
}

void rejectTag() {
  Serial.println("Tag rejected!");
  digitalWrite(GREEN_LED, LED_OFF);
  digitalWrite(RED_LED, LED_ON);
  digitalWrite(BLUE_LED, LED_OFF);
  
  #ifdef DEBUG
  Serial.print("Expected magic number: 0x");
  for (int i = 0; i < MAGIC_NUMBER_SIZE; i++) {
    Serial.print(magicNumber[i], HEX);
  }
  Serial.print(", got: 0x");
  for (int i = 0; i < MAGIC_NUMBER_SIZE; i++) {
    Serial.print(outsideMagicNumber[i], HEX);
  }
  Serial.println("");
  #endif
  
  delay(2000);
}

